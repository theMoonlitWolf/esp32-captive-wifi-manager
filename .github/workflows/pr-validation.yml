on:
  workflow_dispatch: {}
  pull_request:
    types: [opened, synchronize, reopened]
  push:
    branches: [ main ]

name: PR validation â€” Build & checks (components & examples)

env:
  IDF_VERSION_RANGE: '>=5.5.0'

jobs:
  build:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout repo
        uses: actions/checkout@v4

      - name: Prepare runner paths
        run: |
          echo "IDF_PATH=${RUNNER_TEMP}/esp-idf" >> $GITHUB_ENV
          echo "WRAPPER_BASE=${RUNNER_TEMP}/idf-wrapper" >> $GITHUB_ENV
          echo "ARTIFACT_DIR=${RUNNER_TEMP}/esp-artifacts" >> $GITHUB_ENV

      - name: Install helper packages
        run: |
          sudo apt-get update
          sudo apt-get install -y --no-install-recommends \
            git wget make cmake ninja-build ccache python3 python3-pip python3-venv \
            build-essential libncurses-dev flex bison gperf libssl-dev \
            cppcheck clang-format jq dpkg rsync || true

      - name: Resolve esp-idf tag from range (or use default)
        run: |
          set -euo pipefail
          RANGE="${IDF_VERSION_RANGE:-}"
          if [ -z "$RANGE" ]; then
            echo "IDF_VERSION=v5.5.0" >> $GITHUB_ENV
            exit 0
          fi
          MIN_VERSION="${RANGE#>=}"
          MIN_VERSION="${MIN_VERSION#>}"
          MIN_VERSION="${MIN_VERSION#=}"
          MIN_VERSION="${MIN_VERSION#v}"
          TMP_TAGS="/tmp/esp-tags.txt"
          : > "${TMP_TAGS}"
          page=1
          while :; do
            resp="$(curl -sS "https://api.github.com/repos/espressif/esp-idf/tags?per_page=100&page=${page}")"
            len=$(echo "$resp" | jq 'length')
            if [ "$len" -eq 0 ]; then
              break
            fi
            echo "$resp" | jq -r '.[].name' >> "${TMP_TAGS}"
            page=$((page+1))
          done
          if [ ! -s "${TMP_TAGS}" ]; then
            echo "Failed to retrieve tags; falling back to v${MIN_VERSION}"
            echo "IDF_VERSION=v${MIN_VERSION}" >> $GITHUB_ENV
            exit 0
          fi
          sed 's/^v//' "${TMP_TAGS}" \
            | grep -E '^[0-9]+(\.[0-9]+){1,2}$' \
            | sort -V -r > /tmp/esp-tags.filtered
          chosen=""
          while read -r ver; do
            if dpkg --compare-versions "$ver" ge "$MIN_VERSION"; then
              chosen="$ver"
              break
            fi
          done < /tmp/esp-tags.filtered
          if [ -z "$chosen" ]; then
            chosen="${MIN_VERSION}"
          fi
          echo "Resolved tag: v${chosen}"
          echo "IDF_VERSION=v${chosen}" >> $GITHUB_ENV

      - name: Show resolved vars
        run: |
          echo "IDF_VERSION=${IDF_VERSION:-<unset>}"
          echo "IDF_PATH=${IDF_PATH:-<unset>}"
          echo "WRAPPER_BASE=${WRAPPER_BASE:-<unset>}"
          echo "ARTIFACT_DIR=${ARTIFACT_DIR:-<unset>}"

      - name: Clone esp-idf
        run: |
          echo "Cloning esp-idf ${IDF_VERSION} into ${IDF_PATH}"
          git clone --depth 1 --branch "${IDF_VERSION}" https://github.com/espressif/esp-idf.git "${IDF_PATH}"
          ls -la "${IDF_PATH}" || true

      - name: Install esp-idf python requirements (guarded)
        run: |
          python3 -m pip install --upgrade pip || true
          if [ -f "${IDF_PATH}/requirements.txt" ]; then
            python3 -m pip install -r "${IDF_PATH}/requirements.txt"
          elif [ -f "${IDF_PATH}/tools/requirements.txt" ]; then
            python3 -m pip install -r "${IDF_PATH}/tools/requirements.txt"
          else
            echo "No esp-idf requirements.txt found; continuing"
          fi

      - name: Run esp-idf install script (best-effort)
        run: |
          set -e
          if [ -x "${IDF_PATH}/install.sh" ]; then
            "${IDF_PATH}/install.sh" || echo "install.sh failed or required interaction; continuing"
          else
            echo "No install.sh present; skipping toolchain installer"
          fi
      
      - name: Debug - list compile_commands.json found
        if: always()
        shell: bash
        run: |
          set -euo pipefail
          echo "GITHUB_WORKSPACE: ${GITHUB_WORKSPACE:-<unset>}"
          echo "ARTIFACT_DIR: ${ARTIFACT_DIR:-<unset>}"
          echo "WRAPPER_BASE: ${WRAPPER_BASE:-<unset>}"
          echo "--- find under GITHUB_WORKSPACE ---"
          find "${GITHUB_WORKSPACE:-.}" -type f -name compile_commands.json -print -exec sh -c 'echo "---- $1 (head)"; head -n 5 "$1"' _ {} \; || true
          echo "--- find under ARTIFACT_DIR ---"
          [ -n "${ARTIFACT_DIR:-}" ] && find "${ARTIFACT_DIR}" -type f -name compile_commands.json -print -exec sh -c 'echo "---- $1 (head)"; head -n 5 "$1"' _ {} \; || true
          echo "--- find under WRAPPER_BASE ---"
          [ -n "${WRAPPER_BASE:-}" ] && find "${WRAPPER_BASE}" -type f -name compile_commands.json -print -exec sh -c 'echo "---- $1 (head)"; head -n 5 "$1"' _ {} \; || true
      
      - name: Run cppcheck (repo-only, with fallback to file list)
        if: always()
        shell: bash
        run: |
          set -euo pipefail
          shopt -s nullglob
      
          # Ensure artifact dir exists so later upload sees reports even if no builds produced
          mkdir -p "${ARTIFACT_DIR:-${RUNNER_TEMP}/esp-artifacts}"
      
          # Candidate compile_commands.json locations (absolute)
          declare -a candidates
          candidates+=("${GITHUB_WORKSPACE:-.}/build/compile_commands.json")
          for f in "${GITHUB_WORKSPACE:-.}"/examples/*/build/compile_commands.json; do candidates+=("$f"); done
          for f in "${ARTIFACT_DIR}"/*/compile_commands.json; do candidates+=("$f"); done
          for f in "${WRAPPER_BASE}"/examples/*/build/compile_commands.json; do candidates+=("$f"); done
          candidates+=("${WRAPPER_BASE:-}/build/compile_commands.json")
      
          # de-duplicate and keep only existing files
          declare -A seen
          files=()
          for f in "${candidates[@]}"; do
            [ -f "$f" ] || continue
            rp="$(realpath "$f")"
            if [ -z "${seen[$rp]:-}" ]; then
              seen[$rp]=1
              files+=("$f")
            fi
          done
      
          if [ "${#files[@]}" -gt 0 ]; then
            echo "Found compile_commands.json files: ${files[*]}"
            ran=0
            for f in "${files[@]}"; do
              # Filter compile_commands.json to repo-owned translation units only
              prefixes_json=$(printf '%s\n' "${GITHUB_WORKSPACE:-$PWD}" "${ARTIFACT_DIR:-}" "${WRAPPER_BASE:-}" | jq -R -s -c 'split("\n")[:-1]')
              filtered="/tmp/filtered-$(basename "$f")"
              jq --argjson prefixes "$prefixes_json" 'map(select(any($prefixes[]; (.file|startswith(.)))))' "$f" > "$filtered" || true
      
              if [ "$(jq 'length' "$filtered" 2>/dev/null || echo 0)" -eq 0 ]; then
                echo "No repo-owned entries found in $f after filtering; skipping."
                rm -f "$filtered" || true
                continue
              fi
      
              name="$(basename "$(dirname "$f")")"
              report_dir="${ARTIFACT_DIR}/${name}"
              mkdir -p "$report_dir"
      
              echo "Running cppcheck on filtered compile_commands.json ($f) -> report: ${report_dir}/cppcheck.txt"
              # run cppcheck, capture output to artifact dir; do not fail the whole job by default
              if cppcheck --project="$filtered" --enable=warning,performance,portability --inline-suppr 2> "${report_dir}/cppcheck.txt"; then
                echo "cppcheck OK for $f"
              else
                echo "cppcheck reported issues for $f (see ${report_dir}/cppcheck.txt)"
              fi
              ran=1
            done
      
            if [ "$ran" -eq 0 ]; then
              echo "No filtered compile_commands.json produced entries; falling back to file-list mode."
            else
              echo "cppcheck runs complete on compile_commands.json files."
              exit 0
            fi
          else
            echo "No compile_commands.json found in standard locations; falling back to file-list mode."
          fi
      
          # Fallback: run cppcheck on a limited set of repo files (faster and repo-only)
          # Limit scope to likely source directories and tracked files
          echo "Gathering C/C++ source files from repo (components/, examples/, main/, include/, src/)"
          files_to_check=()
          for d in components examples main include src; do
            if [ -d "$d" ]; then
              while IFS= read -r f; do files_to_check+=("$f"); done < <(git ls-files "$d/**/*.c" "$d/**/*.cpp" "$d/**/*.h" "$d/**/*.hpp" 2>/dev/null || true)
            fi
          done
          # also include top-level tracked C/C++ files
          while IFS= read -r f; do files_to_check+=("$f"); done < <(git ls-files '*.c' '*.cpp' '*.h' '*.hpp' 2>/dev/null || true)
      
          # de-duplicate
          declare -A seen2
          unique_files=()
          for f in "${files_to_check[@]}"; do
            [ -f "$f" ] || continue
            rp="$(realpath "$f")"
            if [ -z "${seen2[$rp]:-}" ]; then
              seen2[$rp]=1
              unique_files+=("$f")
            fi
          done
      
          if [ "${#unique_files[@]}" -eq 0 ]; then
            echo "No repo C/C++ files found to run cppcheck on; skipping."
            exit 0
          fi
      
          # run cppcheck on the collected files (less precise than compile_commands.json, but repo-only and faster)
          fallback_report="${ARTIFACT_DIR}/cppcheck-fallback.txt"
          echo "Running cppcheck on ${#unique_files[@]} repo files (fallback). Report -> ${fallback_report}"
          # provide some include dirs if your repo has them; add -I flags as needed
          if cppcheck --enable=warning,performance,portability --inline-suppr "${unique_files[@]}" 2> "${fallback_report}"; then
            echo "cppcheck fallback OK"
          else
            echo "cppcheck fallback reported issues (see ${fallback_report})"
          fi

      - name: Upload build artifacts (collected)
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: esp-build
          path: |
            ${{ env.ARTIFACT_DIR }}
     
      - name: Optional clang-format check (fail on mismatch)
        if: always()
        shell: bash
        run: |
          if command -v clang-format >/dev/null 2>&1 && [ -f .clang-format ]; then
            mismatches=0
            git ls-files '*.c' '*.cpp' '*.h' '*.hpp' | while read -r f; do
              tmp=$(mktemp)
              clang-format --style=file "$f" > "$tmp"
              if ! diff -q "$f" "$tmp" >/dev/null 2>&1; then
                echo "clang-format mismatch: $f"
                diff -u "$f" "$tmp" || true
                mismatches=1
              fi
              rm "$tmp"
            done
            if [ "$mismatches" -ne 0 ]; then
              echo "clang-format mismatches detected"
              exit 1
            fi
            echo "clang-format OK"
          else
            echo "clang-format or .clang-format not available; skipping format check"
          fi
