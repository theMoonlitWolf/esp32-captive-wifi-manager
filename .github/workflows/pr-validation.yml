on:
  pull_request:
    types: [opened, synchronize, reopened]
  push:
    branches: [ main ]

name: PR validation â€” Build, tests, static analysis

# Option A: pin a specific tag (recommended for reproducible builds)
# IDF_VERSION: 'v5.5.0'
# Option B: use a semver range and let the workflow resolve it to the latest matching tag
env:
  IDF_VERSION_RANGE: '>=5.5.0'    # change or clear this; if empty the workflow will fall back to IDF_VERSION_OVERRIDE or a pinned default

jobs:
  build:
    name: Build & validate
    runs-on: ubuntu-latest
    steps:
      - name: Checkout repo
        uses: actions/checkout@v4

      - name: Set IDF_PATH (use runner temp dir)
        run: echo "IDF_PATH=${RUNNER_TEMP}/esp-idf" >> $GITHUB_ENV

      - name: Install helper packages (jq, dpkg, etc.)
        run: |
          sudo apt-get update
          sudo apt-get install -y --no-install-recommends \
            git wget make cmake ninja-build ccache python3 python3-pip python3-venv \
            build-essential libncurses-dev flex bison gperf libssl-dev cppcheck clang-format jq dpkg || true

      - name: Resolve ESP-IDF tag from range (if any)
        id: resolve_idf
        run: |
          set -euo pipefail
          # Priority:
          # 1) If user set IDF_VERSION_OVERRIDE (explicit tag like v5.5.1), use it
          # 2) Else, if IDF_VERSION_RANGE is set (e.g. ">=5.5.0"), query GitHub tags and pick newest matching
          # 3) Else fall back to a hard-coded default (v5.5.0)
          if [ -n "${IDF_VERSION_OVERRIDE:-}" ]; then
            echo "Using explicit override: ${IDF_VERSION_OVERRIDE}"
            echo "IDF_VERSION=${IDF_VERSION_OVERRIDE}" >> $GITHUB_ENV
            exit 0
          fi

          RANGE="${IDF_VERSION_RANGE:-}"
          if [ -z "$RANGE" ]; then
            # default fallback (change if you want another pinned version)
            echo "IDF_VERSION=v5.5.0" >> $GITHUB_ENV
            echo "No range provided; defaulting to v5.5.0"
            exit 0
          fi

          # Normalize min version from range like ">=5.5.0" or "5.5.0"
          MIN_VERSION="${RANGE#>=}"
          MIN_VERSION="${MIN_VERSION#>}"
          MIN_VERSION="${MIN_VERSION#=}"
          MIN_VERSION="${MIN_VERSION#v}"
          echo "Resolving esp-idf tag for minimum version: ${MIN_VERSION}"

          # Fetch tags pages (100 per page) until no more results (handles many tags)
          TMP_TAGS="/tmp/esp-tags.txt"
          : > "${TMP_TAGS}"
          page=1
          while :; do
            resp="$(curl -sS "https://api.github.com/repos/espressif/esp-idf/tags?per_page=100&page=${page}")"
            len=$(echo "$resp" | jq 'length')
            if [ "$len" -eq 0 ]; then
              break
            fi
            echo "$resp" | jq -r '.[].name' >> "${TMP_TAGS}"
            page=$((page+1))
          done

          if [ ! -s "${TMP_TAGS}" ]; then
            echo "Failed to retrieve tags; falling back to v${MIN_VERSION}"
            echo "IDF_VERSION=v${MIN_VERSION}" >> $GITHUB_ENV
            exit 0
          fi

          # normalize and filter numeric tags, sort descending, pick first >= MIN_VERSION
          sed 's/^v//' "${TMP_TAGS}" \
            | grep -E '^[0-9]+(\.[0-9]+){1,2}$' \
            | sort -V -r > /tmp/esp-tags.filtered

          chosen=""
          while read -r ver; do
            if dpkg --compare-versions "$ver" ge "$MIN_VERSION"; then
              chosen="$ver"
              break
            fi
          done < /tmp/esp-tags.filtered

          if [ -z "$chosen" ]; then
            echo "No tag >= ${MIN_VERSION} found; falling back to ${MIN_VERSION}"
            chosen="${MIN_VERSION}"
          fi

          echo "Resolved tag: v${chosen}"
          echo "IDF_VERSION=v${chosen}" >> $GITHUB_ENV

      - name: Show resolved IDF_VERSION and IDF_PATH
        run: |
          echo "IDF_VERSION=$IDF_VERSION"
          echo "IDF_PATH=$IDF_PATH"

      - name: Clone ESP-IDF (${IDF_VERSION})
        run: |
          echo "Cloning esp-idf ${IDF_VERSION} into ${IDF_PATH}"
          git clone --depth 1 --branch "${IDF_VERSION}" https://github.com/espressif/esp-idf.git "${IDF_PATH}"
          ls -la "${IDF_PATH}"

      - name: Install ESP-IDF Python requirements
        run: |
          python3 -m pip install --upgrade pip
          python3 -m pip install -r "${IDF_PATH}/requirements.txt"

      - name: Run esp-idf install script (best-effort, may download toolchains)
        run: |
          set -e
          if [ -x "${IDF_PATH}/install.sh" ]; then
            "${IDF_PATH}/install.sh" || echo "install.sh failed or required interaction; continuing"
          else
            echo "No install.sh present or not executable; skipping"
          fi

      - name: Build (source IDF environment and run idf.py)
        shell: bash
        run: |
          source "${IDF_PATH}/export.sh"
          # set target if needed: idf.py set-target esp32
          idf.py reconfigure || true
          idf.py build
          idf.py size-components || true

      - name: Run unit tests (pytest) if tests/ exists
        shell: bash
        run: |
          if [ -d tests ]; then
            python3 -m pip install pytest || true
            pytest -q tests || (echo "pytest failures" && exit 1)
          else
            echo "No tests/ dir found; skipping pytest"
          fi

      - name: Static analysis (cppcheck) if compile_commands.json exists
        shell: bash
        run: |
          if [ -f build/compile_commands.json ]; then
            cppcheck --project=build/compile_commands.json --enable=warning,performance,portability --error-exitcode=1
          else
            echo "No build/compile_commands.json found; skipping cppcheck"
          fi

      - name: Check formatting with clang-format (optional, fails on mismatch)
        shell: bash
        run: |
          if command -v clang-format >/dev/null 2>&1 && [ -f .clang-format ]; then
            mismatches=0
            git ls-files '*.c' '*.cpp' '*.h' '*.hpp' | while read -r f; do
              tmp=$(mktemp)
              clang-format --style=file "$f" > "$tmp"
              if ! diff -q "$f" "$tmp" >/dev/null 2>&1; then
                echo "clang-format mismatch: $f"
                diff -u "$f" "$tmp" || true
                mismatches=1
              fi
              rm "$tmp"
            done
            if [ "$mismatches" -ne 0 ]; then
              echo "clang-format mismatches detected"
              exit 1
            fi
            echo "clang-format OK"
          else
            echo "clang-format or .clang-format not available; skipping format check"
          fi

      - name: Upload build artifacts
        uses: actions/upload-artifact@v4
        with:
          name: esp-build
          path: build/
